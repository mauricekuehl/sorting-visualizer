export const codeScript = {
  bblsort:
    "function bblSort(arr) {\n  let count = 0;\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = 0; j < arr.length - i - 1; j++) {\n      count++;\n      if (arr[j] > arr[j + 1]) {\n        var temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n  }\n  return;\n}",
  heapsort:
    "let length;\nfunction heap_root(input, i) {\n  var left = 2 * i + 1;\n  var right = 2 * i + 2;\n  var max = i;\n  \n  if (left < length && input[left] > input[max]) {\n    max = left;\n  }\n  \n  if (right < length && input[right] > input[max]) {\n    max = right;\n  }\n  \n  if (max != i) {\n    swape(input, i, max);\n    heap_root(input, max);\n  }\n}\n\nfunction swape(input, i, j) {\n  var temp = input[i];\n  input[i] = input[j];\n  input[j] = temp;\n}\n\n function heapSort(input) {\n  length = input.length;\n  for (var i = Math.floor(length / 2); i >= 0; i -= 1) {\n    heap_root(input, i);\n  }\n  for (i = input.length - 1; i > 0; i--) {\n    swape(input, 0, i);\n    length--;\n    heap_root(input, 0);\n  }\n  return;\n}",
  insertionsort:
    "function insertionSort(arr) {\n  for (let i = 1; i < arr.length; i++) {\n    let key = arr[i];\n    let j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j = j - 1;\n    }\n    arr[j + 1] = key;\n  }\n  return;\n}",
  mergesort:
    "\nunction mergeSort(array) {\n  const auxiliaryArray = array.slice();\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray);\n  return;\n}\n\nfunction mergeSortHelper(mainArray, startIdx, endIdx, auxiliaryArray) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray);\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray);\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray);\n}\n\nfunction doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n  while (i <= middleIdx && j <= endIdx) {\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n        mainArray[k++] = auxiliaryArray[i++];\n    } else {\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }\n  while (i <= middleIdx) {\n    mainArray[k++] = auxiliaryArray[i++];\n  }\n  while (j <= endIdx) {\n    mainArray[k++] = auxiliaryArray[j++];\n  }\n}  ",
  quicksort:
    "function quickSort(arr, left, right) {\n  quickSortMain(arr, left, right);\n  return;\n}  \nfunction partition(arr, left, right) {\n  var pivot = arr[Math.floor((right + left) / 2)],\n    i = left,\n    j = right;\n\n  while (i <= j) {\n    while (arr[i] < pivot) {\n      i++;\n    }\n    while (arr[j] > pivot) {\n      j--;\n    }\n    if (i <= j) {\n      var temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    }\n  }\n  return i;\n}\nfunction quickSortMain(arr, left, right) {\n  var index;\n  if (arr.length > 1) {\n    index = partition(arr, left, right);\n    if (left < index - 1) {\n      quickSortMain(arr, left, index - 1);\n    }\n    if (index < right) quickSortMain(arr, index, right);\n  }\n}",
  radixsort:
    "function radixSort(arr) {\n  var idx1, idx2, idx3, len1, len2, radix, radixKey;\n  var radices = {},\n    buckets = {},\n    curr;\n  var currLen, currBucket;\n\n  len1 = arr.length;\n  len2 = 10;\n\n  for (idx1 = 0; idx1 < len1; idx1++) {\n    radices[arr[idx1].toString().length] = 0;\n  }\n  for (radix in radices) {\n    len1 = arr.length;\n    for (idx1 = 0; idx1 < len1; idx1++) {\n      curr = arr[idx1];\n      currLen = curr.toString().length;\n      if (currLen >= radix) {\n        radixKey = curr.toString()[currLen - radix];\n        if (!buckets.hasOwnProperty(radixKey)) {\n          buckets[radixKey] = [];\n        }\n        buckets[radixKey].push(curr);\n      } else {\n        if (!buckets.hasOwnProperty('0')) {\n          buckets['0'] = [];\n        }\n        buckets['0'].push(curr);\n      }\n    }\n    idx1 = 0;\n    for (idx2 = 0; idx2 < len2; idx2++) {\n      if (buckets[idx2] != null) {\n        currBucket = buckets[idx2];\n        len1 = currBucket.length;\n        for (idx3 = 0; idx3 < len1; idx3++) {\n          arr[idx1++] = currBucket[idx3];\n        }\n      }\n    }\n    buckets = {};\n  }\n  return;\n}\n",
  shellsort:
    "function shellSort(arr) {\n  var increment = arr.length / 2;\n  while (increment > 0) {\n    for (let i = increment; i < arr.length; i++) {\n      var j = i;\n      var temp = arr[i];\n      while (j >= increment && arr[j - increment] > temp) {\n        arr[j] = arr[j - increment];\n        j = j - increment;\n      }\n      arr[j] = temp;\n    }\n    if (increment == 2) {\n      increment = 1;\n    } else {\n      increment = parseInt((increment * 5) / 11);\n    }\n  }\n  return;\n}\n  ",
  customsort:
    "function customSort(arr) {\n  //this is Bubble Sort as an example\n  let count = 0;\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = 0; j < arr.length - i - 1; j++) {\n      count++;\n      if (arr[j] > arr[j + 1]) {\n        var temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n        //visulieses a swap\n        swap(j, j + 1)\n      }\n    }\n  }\n  return;\n}",
};
